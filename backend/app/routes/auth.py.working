from fastapi import APIRouter, Depends, HTTPException, status
from sqlalchemy.orm import Session
from sqlalchemy import text
from passlib.context import CryptContext
from datetime import datetime, timedelta
from jose import jwt, JWTError

from app.core.database import get_db
from app.schemas.users import LoginRequest, LoginResponse, UserProfile

router = APIRouter()

# Password hashing
pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")

# JWT settings
SECRET_KEY = "your-secret-key-here"
ALGORITHM = "HS256"
ACCESS_TOKEN_EXPIRE_MINUTES = 30

def verify_password(plain_password: str, hashed_password: str) -> bool:
    return pwd_context.verify(plain_password, hashed_password)

@router.post("/login", response_model=LoginResponse)
async def login(login_data: LoginRequest, db: Session = Depends(get_db)):
    """User login endpoint"""
    
    # Query user from database
    result = db.execute(text("""
        SELECT 
            u.id, u.name, u.surname, u.email,
            u.password_hash as password, u.role, false as must_change_password
        FROM users u
        WHERE u.email = :email
    """), {"email": login_data.email})
    
    user_data = result.fetchone()
    
    if not user_data:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Invalid email or password"
        )
    
    # Verify password
    if not verify_password(login_data.password, user_data.password):
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Invalid email or password"
        )
    
    # Create access token
    access_token_expires = timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)
    access_token = create_access_token(
        data={"sub": str(user_data.id)}, expires_delta=access_token_expires
    )
    
    # Update last login
    db.execute(text("""
        UPDATE users SET last_login = :last_login WHERE id = :user_id
    """), {"last_login": datetime.now(), "user_id": user_data.id})
    db.commit()
    
    # Return login response
    return LoginResponse(
        access_token=access_token,
        token_type="bearer",
        expires_in=ACCESS_TOKEN_EXPIRE_MINUTES * 60,
        user={
            "id": str(user_data.id),
            "username": user_data.email,
            "name": user_data.name,
            "surname": user_data.surname,
            "first_name": user_data.name,
            "last_name": user_data.surname,
            "email": user_data.email,
            "role": user_data.role,
            "permissions": {},
            "is_active": True,
            "last_login": datetime.now(),
            "must_change_password": user_data.must_change_password
        }
    )

def create_access_token(data: dict, expires_delta: timedelta = None):
    to_encode = data.copy()
    if expires_delta:
        expire = datetime.utcnow() + expires_delta
    else:
        expire = datetime.utcnow() + timedelta(minutes=15)
    to_encode.update({"exp": expire})
    encoded_jwt = jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)
    return encoded_jwt

@router.get("/me", response_model=UserProfile)
async def get_current_user(db: Session = Depends(get_db)):
    """Get current user profile"""
    # This is a simplified version - in production you'd decode JWT token
    return {"message": "User profile endpoint"}

def get_current_user_dep():
    """Dependency to get current user from JWT token"""
    # For now, return a dummy function
    # In production, this would decode JWT and return user
    def _get_current_user():
        return {"id": "dummy-user", "email": "dummy@example.com", "role": "admin"}
    return _get_current_user

@router.post("/change-password")
async def change_password(
    current_password: str,
    new_password: str,
    user_id: str,
    db: Session = Depends(get_db)
):
    """Change user password"""
    try:
        # Verifica password attuale
        result = db.execute(text("""
            SELECT password_hash, must_change_password 
            FROM users 
            WHERE id = :user_id
        """), {"user_id": user_id})
        
        user_data = result.fetchone()
        if not user_data:
            raise HTTPException(status_code=404, detail="User not found")
        
        # Verifica password attuale
        if not verify_password(current_password, user_data.password_hash):
            raise HTTPException(status_code=401, detail="Current password is incorrect")
        
        # Hash nuova password
        new_password_hash = pwd_context.hash(new_password)
        
        # Aggiorna password e rimuovi flag must_change_password
        db.execute(text("""
            UPDATE users 
            SET password_hash = :new_password_hash, 
                must_change_password = false,
                updated_at = :updated_at
            WHERE id = :user_id
        """), {
            "new_password_hash": new_password_hash,
            "updated_at": datetime.now(),
            "user_id": user_id
        })
        
        db.commit()
        
        return {"message": "Password changed successfully"}
        
    except Exception as e:
        db.rollback()
        raise HTTPException(status_code=500, detail=str(e))
